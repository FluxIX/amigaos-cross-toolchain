--- binutils-2.9.1/gas/config/tc-sh.c	Fri May  1 08:44:45 1998
+++ binutils-2.9.1/gas/config/tc-sh.c	Sun Aug 23 00:00:00 1998
@@ -853,7 +853,7 @@ insert (where, how, pcrel)
 	       2,
 	       &immediate,
 	       pcrel,
-	       how);
+	       how, 0);
 }
 
 static void
@@ -1020,7 +1020,7 @@ md_assemble (str)
       /* Output a CODE reloc to tell the linker that the following
          bytes are instructions, not data.  */
       fix_new (frag_now, frag_now_fix (), 2, &abs_symbol, 0, 0,
-	       BFD_RELOC_SH_CODE);
+	       BFD_RELOC_SH_CODE, 0);
       seg_info (now_seg)->tc_segment_info_data.in_code = 1;
     }
 
@@ -1072,7 +1072,7 @@ sh_frob_label ()
       if (frag_now != last_label_frag
 	  || offset != last_label_offset)
 	{	
-	  fix_new (frag_now, offset, 2, &abs_symbol, 0, 0, BFD_RELOC_SH_LABEL);
+	  fix_new (frag_now, offset, 2, &abs_symbol, 0, 0, BFD_RELOC_SH_LABEL, 0);
 	  last_label_frag = frag_now;
 	  last_label_offset = offset;
 	}
@@ -1089,7 +1089,7 @@ sh_flush_pending_output ()
       && seg_info (now_seg)->tc_segment_info_data.in_code)
     {
       fix_new (frag_now, frag_now_fix (), 2, &abs_symbol, 0, 0,
-	       BFD_RELOC_SH_DATA);
+	       BFD_RELOC_SH_DATA, 0);
       seg_info (now_seg)->tc_segment_info_data.in_code = 0;
     }
 }
@@ -1202,7 +1202,7 @@ s_uses (ignore)
       return;
     }
 
-  fix_new_exp (frag_now, frag_now_fix (), 2, &ex, 1, BFD_RELOC_SH_USES);
+  fix_new_exp (frag_now, frag_now_fix (), 2, &ex, 1, BFD_RELOC_SH_USES, 0);
 
   demand_empty_rest_of_line ();
 }
@@ -1440,7 +1440,7 @@ sh_frob_section (abfd, sec, ignore)
 	 fragment address, so we undo that adjustment here.  */
       subseg_change (sec, 0);
       fix_new (sym->sy_frag, S_GET_VALUE (sym) - sym->sy_frag->fr_address,
-	       4, &abs_symbol, info.count, 0, BFD_RELOC_SH_COUNT);
+	       4, &abs_symbol, info.count, 0, BFD_RELOC_SH_COUNT, 0);
     }
 }
 
@@ -1492,7 +1492,7 @@ md_convert_frag (headers, seg, fragP)
     case C (COND_JUMP, COND8):
       subseg_change (seg, 0);
       fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
-	       1, BFD_RELOC_SH_PCDISP8BY2);
+	       1, BFD_RELOC_SH_PCDISP8BY2, 0);
       fragP->fr_fix += 2;
       fragP->fr_var = 0;
       break;
@@ -1500,7 +1500,7 @@ md_convert_frag (headers, seg, fragP)
     case C (UNCOND_JUMP, UNCOND12):
       subseg_change (seg, 0);
       fix_new (fragP, fragP->fr_fix, 2, fragP->fr_symbol, fragP->fr_offset,
-	       1, BFD_RELOC_SH_PCDISP12BY2);
+	       1, BFD_RELOC_SH_PCDISP12BY2, 0);
       fragP->fr_fix += 2;
       fragP->fr_var = 0;
       break;
@@ -1578,13 +1578,13 @@ md_convert_frag (headers, seg, fragP)
 		 seg_info (seg)->dot,
 #endif
 		 fragP->fr_address + fragP->fr_fix + 6,
-		 1, BFD_RELOC_SH_PCDISP8BY2);
+		 1, BFD_RELOC_SH_PCDISP8BY2, 0);
 
 	/* Set up a jump instruction.  */
 	buffer[highbyte + 2] = 0xa0;
 	buffer[lowbyte + 2] = 0;
 	fix_new (fragP, fragP->fr_fix + 2, 2, fragP->fr_symbol,
-		 fragP->fr_offset, 1, BFD_RELOC_SH_PCDISP12BY2);
+		 fragP->fr_offset, 1, BFD_RELOC_SH_PCDISP12BY2, 0);
 
 	/* Fill in a NOP instruction.  */
 	buffer[highbyte + 4] = 0x0;
@@ -1755,7 +1755,7 @@ sh_handle_align (frag)
       && frag->fr_offset > 1
       && now_seg != bss_section)
     fix_new (frag, frag->fr_fix, 2, &abs_symbol, frag->fr_offset, 0,
-	     BFD_RELOC_SH_ALIGN);
+	     BFD_RELOC_SH_ALIGN, 0);
 
   if (frag->fr_type == rs_align_code
       && frag->fr_next->fr_address - frag->fr_address - frag->fr_fix != 0)
@@ -2115,9 +2115,9 @@ sh_do_align (n, fill, len, max)
          .byte.  */
       frag_align (1, 0, 0);
       if (target_big_endian)
-	frag_align_pattern (n, big_nop_pattern, sizeof big_nop_pattern, max);
+	frag_align_pattern (n, (const char *) big_nop_pattern, sizeof big_nop_pattern, max);
       else
-	frag_align_pattern (n, little_nop_pattern, sizeof little_nop_pattern,
+	frag_align_pattern (n, (const char *) little_nop_pattern, sizeof little_nop_pattern,
 			    max);
       return 1;
     }
