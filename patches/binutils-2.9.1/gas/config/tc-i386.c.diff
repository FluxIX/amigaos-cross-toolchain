--- binutils-2.9.1/gas/config/tc-i386.c	Fri May  1 08:44:41 1998
+++ binutils-2.9.1/gas/config/tc-i386.c	Sun Aug 23 00:00:00 1998
@@ -1807,7 +1807,7 @@ md_assemble (line)
 	else
 	  {
 	    fix_new_exp (frag_now, p - frag_now->fr_literal, size,
-			 i.disps[0], 1, reloc (size, 1, i.disp_reloc[0]));
+			 i.disps[0], 1, reloc (size, 1, i.disp_reloc[0]), 0);
 
 	  }
       }
@@ -1826,7 +1826,7 @@ md_assemble (line)
 	  md_number_to_chars (p + 1, (valueT) i.imms[1]->X_add_number, 4);
 	else
 	  fix_new_exp (frag_now, p + 1 - frag_now->fr_literal, 4,
-		       i.imms[1], 0, BFD_RELOC_32);
+		       i.imms[1], 0, BFD_RELOC_32, 0);
 	if (i.imms[0]->X_op != O_constant)
 	  as_bad ("can't handle non absolute segment in long call/jmp");
 	md_number_to_chars (p + 5, (valueT) i.imms[0]->X_add_number, 2);
@@ -1952,7 +1952,7 @@ md_assemble (line)
 			insn_size += 4;
 			fix_new_exp (frag_now, p - frag_now->fr_literal, 4,
 					    i.disps[n], 0, 
-					    TC_RELOC(i.disp_reloc[n], BFD_RELOC_32));
+					    TC_RELOC(i.disp_reloc[n], BFD_RELOC_32), 0);
 		      }
 		  }
 	      }
@@ -2026,7 +2026,7 @@ md_assemble (line)
 			  }
 #endif
 			fix_new_exp (frag_now, p - frag_now->fr_literal, size,
-				     i.imms[n], pcrel, r_type);
+				     i.imms[n], pcrel, r_type, 0);
 		      }
 		  }
 	      }
@@ -2577,7 +2577,7 @@ md_estimate_size_before_relax (fragP, se
 				     think it does not matter that much, as
 				     this will be right most of the time. ERY*/
 		    S_GET_SEGMENT(fragP->fr_symbol) == undefined_section)?
-		   BFD_RELOC_386_PLT32 : BFD_RELOC_32_PCREL);
+		   BFD_RELOC_386_PLT32 : BFD_RELOC_32_PCREL, 0);
 	  break;
 
 	default:
@@ -2593,7 +2593,7 @@ md_estimate_size_before_relax (fragP, se
 				     presence of @PLT, but I cannot see how
 				     to get to that from here.  ERY */
 		    S_GET_SEGMENT(fragP->fr_symbol) == undefined_section)?
-		   BFD_RELOC_386_PLT32 : BFD_RELOC_32_PCREL);
+		   BFD_RELOC_386_PLT32 : BFD_RELOC_32_PCREL, 0);
 	  break;
 	}
       frag_wane (fragP);
@@ -2729,7 +2729,7 @@ md_create_long_jump (ptr, from_addr, to_
       md_number_to_chars (ptr, (valueT) 0xe9, 1);/* opcode for long jmp */
       md_number_to_chars (ptr + 1, (valueT) offset, 4);
       fix_new (frag, (ptr + 1) - frag->fr_literal, 4,
-	       to_symbol, (offsetT) 0, 0, BFD_RELOC_32);
+	       to_symbol, (offsetT) 0, 0, BFD_RELOC_32, 0);
     }
   else
     {
@@ -3064,7 +3064,11 @@ md_section_align (segment, size)
      segT segment;
      valueT size;
 {
-#ifdef OBJ_AOUT
+/* fnf hack - check to see if BFD really should handle this or not.  It is currently
+   not, at least for the BeOS port, and since stdio does not guarantee that holes
+   in files are zero filled, the holes are ending up with random contents.  This
+   really screws things like gcc's bootstrap success/fail testing. */
+#if 1
 #ifdef BFD_ASSEMBLER
   /* For a.out, force the section size to be aligned.  If we don't do
      this, BFD will align it for us, but it will not write out the
